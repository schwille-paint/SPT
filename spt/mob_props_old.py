import numpy as np
import pandas as pd
from scipy.optimize import curve_fit
import matplotlib.pyplot as plt
import trackpy as tp

#%%
def get_linkprops_noMSD(link,locs_info,length_hp):
    '''
    Calculates various trajectory properties without performing MSD analysis:
        1) Trajectory lengths
    
    Parameters
    ---------
    link : pandas.Dataframe  
        Same locs as locs, index set to 'particle' generated by trackpy.link,
        assigning each localization to a particle trajectory
    length_hp : int
        Cut-off value removing all trajectories shorter than length_hp. Set to
        100 by default.
    Returns
    -------
    link_props : pandas.DataFrame
    '''
    
    #### Get some properties
    print('Calculating means and lengths...')
    link_props=link.groupby('particle').mean()
    link_props['min_frame']=link.frame.groupby('particle').min() # get first frame of trajectory
    link_props['max_frame']=link.frame.groupby('particle').max() # get last frame of trajectory
    link_props['len']=np.subtract(link.frame.groupby('particle').max(),link.frame.groupby('particle').min()) + 1 # get trajectory length
    
    #### Reduce to traces above length high pass
    print('Applying track length high pass...')
    pass_particle=link_props[(link_props.len>length_hp)].index
    link=link.loc[pass_particle,:]
    link_props=link_props[link_props.len>length_hp] 
    
    #### Extract numTracks vs frames and fit to f(x)=a*exp(-x/b)+c
    print('Fitting decay of number of tracks per frame')   
    numtrack_fit=get_numtracks_fit(link_props,locs_info)
    
    #### Format link_props such that the output with key 'props' is identical to output from get_linkprops
    link_props=pd.concat([link_props,numtrack_fit],keys=['props','numtrack_fit'],axis=1)
     
    return link_props

#%%
def get_numtracks(link_props,frames):
    '''
    
    '''
    
    #### Initialize variables: iterable over all frames and numTrack set to 0 in each frame
    numTracks = pd.Series(np.zeros(len(frames)))
    
    print('Calculating number of tracks per frame...')
    for current_frame in frames:
        
        #### Compute sum of 'active' trajectories satisfying: min_frame <= current_frame <= max_frame
        larger_minFrame=link_props['min_frame']<=current_frame
        smaller_maxFrame=link_props['max_frame']>=current_frame
        istrue = larger_minFrame == smaller_maxFrame
        
        #### Store sum in numTracks
        numTracks[current_frame] = istrue.sum()
    
    return numTracks


#%%
def get_numtracks_fit(link_props,locs_info,saveplot=True):
    
    #### Calculate number of tracks per frame
    NoFrames=link_props['max_frame'].max()+1 # get total number of rames
    frames=range(0,NoFrames) 
    numtracks=get_numtracks(link_props,frames) # get number of tracks per frame
    
    #### Define fit model and fit to numtracks vs frames
    def exp_fit(x,a,b,c):
        f=a*np.exp(-x/b)+c
        return f

    popt,pcov=curve_fit(exp_fit,xdata=numtracks.index,
                          ydata=numtracks,
                          p0=[numtracks[0], # No of tracks in first frame
                              len(frames)/2, # decay constant set to half of acquisition length
                              numtracks[-(int(len(frames)*0.1)):].mean()]) # mean No of tracks over last 10 % of acquisition     
    
    #### Plot No of tracks vs frames incl fit
    f=plt.figure(num=20,figsize=[4,3])
    f.subplots_adjust(left=0.2,right=0.99,bottom=0.2,top=0.95)
    f.clear()
    ax=f.add_subplot(111)
    ax.plot(numtracks.index,numtracks,label='data')
    ax.plot(numtracks.index,exp_fit(numtracks.index,*popt),'r',linewidth=2,label='fit')
    ax.set_xlabel('Frames')
    ax.set_ylabel('# of Tracks')
    ax.legend(loc=1)
    
#    if saveplot==True:
#        ### Get path of file
#        path=info[0]['File']
#        path=os.path.splitext(path)[0]
#        plt.savefig(os.path.join(path+'N-tracks_vs_frames.pdf'))

        
    #### Prepare output            
    s_out=pd.DataFrame()
    s_out_init = pd.Series(np.ones(len(link_props)))
    s_out['a']=s_out_init*popt[0]
    s_out['b']=s_out_init*popt[1]
    s_out['c']=s_out_init*popt[2]
    s_out.set_index(link_props.index,inplace=True)
    
    return s_out    

    

#%%    
def get_linkprops(link,locs_info,length_hp=100,max_lagtime=200):
    '''
    Calculates various trajectory properties:
        1) Trajectory lengths
        2) MSD analysis results
    
    Parameters
    ---------
    link : pandas.Dataframe  
        Same locs as locs, index set to 'particle' generated by trackpy.link,
        assigning each localization to a particle trajectory
    length_hp : int
        Cut-off value removing all trajectories shorter than length_hp. Set to
        100 by default.
    max_lagtime: int
        Maximal lagtime to which MSD is calculated. Set to 200 by default.
    Returns
    -------
    link_props : pandas.DataFrame
    '''
   
    #### Get some properties
    print('Calculating means and lengths...')
    link_props=link.groupby('particle').mean()
    link_props['min_frame']=link.frame.groupby('particle').min() # get first frame of trajectory
    link_props['max_frame']=link.frame.groupby('particle').max() # get last frame of trajectory
    link_props['len']=np.subtract(link.frame.groupby('particle').max(),link.frame.groupby('particle').min()) + 1 # get trajectory length
    
    #### Reduce to traces above length high pass
    print('Applying track length high pass...')
    pass_particle=link_props[(link_props.len>length_hp)].index
    link=link.loc[pass_particle,:]
    link_props=link_props[link_props.len>length_hp]
    
    #### Extract numTracks vs frames and fit to f(x)=a*exp(-x/b)+c
    print('Fitting decay of number of tracks per frame')   
    numtrack_fit=get_numtracks_fit(link_props,locs_info)
    
    #### MSD 
    print('Calculating msds...')
    if max_lagtime=='max':
        tau_max=link_props['len'].max()
    else:
        tau_max=max_lagtime
        
    imsd=tp.imsd(link,1,1,max_lagtime=tau_max)
       
    #### Fit individual msds
    print('Fitting msds...')
    imsd_logfit=imsd.apply(lambda df:fit_logiMSD(df),axis=0)
    imsd_fit_iter=imsd.apply(lambda df:fit_iMSD_free_iterate(df),axis=0)
    imsd_fit=pd.concat([imsd_logfit.T,imsd_fit_iter.T],axis=1)
    
    #### Combine link_props, imsd_fit & imsd
    link_props=pd.concat([link_props,numtrack_fit,imsd_fit,imsd.T],keys=['props','numtrack_fit','fit','msd'],axis=1)
     
    return link_props
#%%
def fit_logiMSD(msd,plot=False):
    '''
    Logarithmic weighted fitting of individual mean square displacements (msd) as given by trackpy.iMSD() 
    assuming following form for the msd: 
        
        msd=A*t^n
            A = Amplitude prop. to diffsuion coefficient D
            n = Determines diffusion mode, i.e. n=1 <-> Free diffusion
            t = Lagtime 
            
        -> log(msd)=log(A)+n*log(t)
    '''
    
    #### Absolute error of logarithmic msd
    def abs_err_logmsd(msd):
        #### Relative error of msd
        def rel_err_msd(N,n):
            sr_msd=(2*n**2+1)/((3*n)*(N-n+1))
            sr_msd=np.sqrt(sr_msd)
            return sr_msd
        
        sa_logmsd=np.log(msd)+np.log(rel_err_msd(len(msd),msd.index.astype(float)))
        #### Set last value to finite number
        sa_logmsd.iloc[-1]=sa_logmsd.iloc[-2]
        return sa_logmsd
    
    #### Fit function
    def fitfunc(logtau,A,n):
        logmsd=np.log(A)+n*logtau
        return logmsd
    
    #### Drop NaN
    msd.dropna(inplace=True)
    
    #### Prepare fit
    x=np.log(msd.index.astype(float))
    y=np.log(msd)
    yerr=abs_err_logmsd(msd)
    #### Cut off long lag times
    x=x[:int(len(x)*0.25)]
    y=y.iloc[:int(len(y)*0.25)]
    yerr=yerr.iloc[:int(len(yerr)*0.25)]
    #### Initial value
    p0=[msd.iloc[0],1.]
    try:
        popt,pcov=curve_fit(fitfunc,x,y,p0=p0,sigma=yerr,absolute_sigma=True)
        perr=np.sqrt(np.diag(pcov))
    except RuntimeError:
        popt=np.full(2,np.nan)
        perr=np.full(2,np.nan)
    except ValueError:
        popt=np.full(2,np.nan)
        perr=np.full(2,np.nan)
    except TypeError:
        popt=np.full(2,np.nan)
        perr=np.full(2,np.nan)
    
    if plot:
        #### Plotting for checks
        f=plt.figure(num=12,figsize=[4,3])
        f.subplots_adjust(left=0.1,right=0.99,bottom=0.1,top=0.99)
        f.clear()
        ax=f.add_subplot(111)
        ax.errorbar(np.log(msd.index.astype(float)),np.log(msd),yerr=0.1*abs_err_logmsd(msd),fmt='-x',c='k',alpha=0.2)
        ax.plot(x,fitfunc(x,*popt),'-',c='r',lw=4)
        
    #### Assign tou output
    s_out=pd.Series({'A':popt[0],'A_err':perr[0],'n':popt[1],'n_err':perr[1]})
    
    return s_out

#%%
def fit_iMSD_free(msd,p,plot=False):
    '''

    '''

    #### Fit function
    def fitfunc(tau,a,b):
        msd=a+b*tau
        return msd
    
    #### Prepare fit
    x=msd.index.astype(float)
    y=msd
    #### Cut off long lag times
    x=x[:p]
    y=y.iloc[:p]
    #### Initial value
    p0=[msd.iloc[0],msd.iloc[10]-msd.iloc[0]]
    try:
        popt,pcov=curve_fit(fitfunc,x,y,p0=p0,sigma=None,absolute_sigma=False)
        perr=np.sqrt(np.diag(pcov))
    except RuntimeError:
        popt=np.full(2,np.nan)
        perr=np.full(2,np.nan)
    except ValueError:
        popt=np.full(2,np.nan)
        perr=np.full(2,np.nan)
    except TypeError:
        popt=np.full(2,np.nan)
        perr=np.full(2,np.nan)
    
    if plot:
        #### Plotting for checks
        f=plt.figure(num=11,figsize=[4,3])
        f.subplots_adjust(left=0.1,right=0.99,bottom=0.1,top=0.99)
        f.clear()
        ax=f.add_subplot(111)
        ax.plot(msd.index.astype(float),msd,'-x',c='k',alpha=0.2)
        ax.plot(x,fitfunc(x,*popt),'-',c='r',lw=4)
        
    #### Assign tou output
    s_out=pd.Series({'a':popt[0],'a_err':perr[0],'b':popt[1],'b_err':perr[1]})
    
    return s_out

#%%
def fit_iMSD_free_iterate(msd,max_it=5,plot=False):
    '''
    
    '''
    
    #### Drop NaN
    msd.dropna(inplace=True)
    #### Set inital track length that will be fitted to 10% of full track length
    p=[int(len(msd)*0.2)]
    
    i=0
    while i<max_it:

        #### Fit
        s_out=fit_iMSD_free(msd,p[-1],plot=plot)
        x=np.abs(s_out['a']/s_out['b'])
        
        #### Assign iteration and fitted track length
        s_out['p']=p[-1]
        s_out['max_it']=i+1
        
        #### Update optimal track length to be fitted
        try:
            p=p+[int(np.ceil(2+2.7*x**0.5))]
        except:
            break
            
        if np.abs(p[-1]-p[-2])<1:
            break
        i+=1
        
    return s_out

 