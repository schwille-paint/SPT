'''
.. _picasso.localize:
    https://picassosr.readthedocs.io/en/latest/localize.html
.. _picasso.render:
    https://picassosr.readthedocs.io/en/latest/render.html
.. _trackpy:
    http://soft-matter.github.io/trackpy/v0.4.2/
'''

import numpy as np
import pandas as pd
from tqdm import tqdm
import matplotlib.pyplot as plt
import trackpy as tp
import os
### Load custom modules
import picasso.io as io

#%%
def get_link(locs,search_range,memory):
    '''
    Apply trackpy.link_df() (`trackpy`_) on localizations with given search_range and memory to get trajectories sorted by group and frame.
    All tracks shorter or equal to 10 frames are removed.
    
    Args:
        locs(pandas.DataFrame):        Localizations as generated by `picasso.localize`_  as pandas.DataFrame
        info(picasso.io):              Info _locs.yaml to _locs.hdf5 localizations as list of dictionaries.
        search_range(int):             Localizations within search_range (spatial) will be connected to tracks (see trackpy.link_df)
        memory(int):                   Localizations within memory (temporal) will be connected to tracks (see trackpy.link_df)
        
    Return:
        pandas.DataFrame:
            Linked trajectories using trackpy.link().
            
                - ``group`` instead of ``particle`` column for `picasso.render`_ compatibility.
                - All trajectories with <= 10 localizations are already removed!!  
    ''' 
    ### Link locs
    link= tp.link(locs,
                  search_range,
                  memory=memory,
                  link_strategy='hybrid',
                  )
    ### Sort and rename
    print('Sorting by [group,frame] ... ')
    link.sort_values(by=['particle','frame'],ascending=True,inplace=True)
    link=link.rename(columns={'particle':'group'}) # Rename to groups for picasso compatibility
    
    ### Throw away tracks with only 10 localizations
    link=drop_shorttracks(link)
   
    return link

#%%
def drop_shorttracks(df,min_n_locs=10):
    '''
    Remove trajectories with less localizations than min_n_locs from output of get_link().
    
    Args:
        df(pandas.DataFrame): Trajectories pandas.DataFrame, i.e. output of get_link() (see also trackpy.link())
        min_n_locs(int=10):   Trajectories having less localizations than min_n_locs will be removed from df
    Returns:
        pandas.DataFrame: ``df`` with short trajectories < min_n_locs removed.
    '''
    
    print('Dropping short trajectories ...')
    groups,group_locs = np.unique(df.group.values,return_counts=True)
    in_groups = groups[group_locs >= min_n_locs]
    df_out = df.query('group in @in_groups')
    
    return df_out

#%%
def scan_sr_mem(locs,info,path,sr,mem,roi=True,timewindow=True):
    '''
    Quick scan using get_link() (`trackpy`_) algorithm using tuples of ``search_ranges`` and ``memory`` 
    over center ROI and starting time window of the video. Corresponding plot will be saved using plot_scan_results().
    This is implemented in order to quickly estimate optimum linking parameters.
    
    Args:
        locs(pandas.DataFrame):   Localizations as generated by `picasso.localize`_  as pandas.DataFrame
        info(picasso.io):         Info _locs.yaml to _locs.hdf5 localizations as list of dictionaries.
        path(str):                Path to _locs.hdf5 file for saving output
        sr(list(int)):            List of search_ranges to scan (see trackpy.link)
        mem(list(int)):           List of memory values to scan  (see trackpy.link)
        roi(bool=True):           If True scan is performed on cropped video to **center 200^2 px** FOV
        timewindow(bool=True):    If True scan is performed on first **300 frames** of video only

    Returns:
        list:
            - [0] (pandas.DataFrame): Multi-Index: Tuple (``search_range``, ``memory``) with columns:
                
                - ``len_med``: Median track length
                - ``numtracks``: Number of linked tracks
                - ``search_range``: See above
                - ``memory``: See above
                
            - [1] (float): 
                
                Proximity, i.e. 90% of all nearest neighbor distances between localizations
                corresponding to first 100 frames (full FOV) are greater than proximity (px).
    '''
    
    #######
    ''' Get median critical proximity of all localizations in the first 100 frames
        Critical Proximity: 90% of all next-neighbor distances are greater than critical proximity
    '''
    ######
    if info[0]['Frames']>=100:
        prox=[np.percentile(tp.proximity(locs.loc[locs.frame==f,:]),10) for f in range(100)]
        prox=np.median(prox) 
    else:
        prox=[np.percentile(tp.proximity(locs.loc[locs.frame==f,:]),10) for f in range(info[0]['Frames'])]
        prox=np.median(prox)
    
    #######
    ''' 1) Crop locs to 200px^2 center FOV and 
        2) take only first 300 frames of _locs than
        3) perform scan over search_range and memory using get_link()
        4) Plot and save plot
    '''
    ######
    ### Crop stack to 200px^2 center FOV
    if roi==True:
        img_size=info[0]['Height'] # get image size
        roi_width=100
        locs=locs[(locs.x>(img_size/2-roi_width))&(locs.x<(img_size/2+roi_width))]
        locs=locs[(locs.y>(img_size/2-roi_width))&(locs.x<(img_size/2+roi_width))]
        
    ### Take only first 300 frames of stack
    if timewindow==True:
        locs=locs[locs.frame<=300]

    ### Scan loop over tuple (search_range,memory) 
    df_out=pd.DataFrame(columns=['len_med','numtracks','sr','mem']) # Init output
    idx=0
    for s in sr:
        for m in mem:  
            #### Link localizations via trackpy
            link=get_link(locs,s,m) 
            
            ### Assign
            groups,group_locs = np.unique(link.group.values,return_counts=True)
            len_med = np.median(group_locs)
            num_tracks = len(groups)
            df_temp=pd.DataFrame({'len_med':len_med,
                                  'numtracks':num_tracks,
                                  'sr':s,
                                  'mem':m},index=[(s,m)])
            
            df_out=pd.concat([df_out,df_temp])
            idx+=idx
    
    plot_scan_results(df_out,prox)
    
    
    ### Save plot
    path=os.path.splitext(path)[0]
    plt.savefig(os.path.join(path+'_scan.pdf'),transparent=True)
    
    return [df_out,prox]

#%%
def plot_scan_results(df,prox):
    '''
    Quickly plot results in scan_sr_mem().
    
    Args:
        df(pandas.DataFrame): Return DataFrame of scan_sr_mem()[0].
        prox(float):          Return DataFrame of scan_sr_mem()[1].
    '''
    
    f=plt.figure(num=21,figsize=[6,3])
    f.subplots_adjust(left=0.15,right=0.85,bottom=0.2,top=0.75)
    f.clear()
    
    plt.title(r'90$\%$ of all NN distances > '+'%.1f px'%(prox))
    
    ax=f.add_subplot(111)
    ax.plot(np.arange(0,len(df),1),df.len_med,'-o',c='k')
    ax.set_xticks(np.arange(0,len(df),1))
    ax.set_xlim(-1,len(df))
    ax.set_xticklabels(df.sr)
    ax.set_xlabel('Search range (px)')
    ax.set_ylabel('Track length (frames)')
    
    #### Second x-axis
    ax1=ax.twiny()
    ax1.xaxis.set_ticks_position('top')
    ax1.xaxis.set_label_position('top')
    ax1.set_xticks(np.arange(0,len(df),1))
    ax1.set_xlim(-1,len(df))
    ax1.set_xticklabels(df.mem)
    ax1.set_xlabel('Memory (frames)',color='k')
    
    ##### Second y axis
    ax2=ax.twinx()
    ax2.plot(np.arange(0,len(df),1),df.numtracks,'-o',c='grey')
    ax2.set_ylabel('# Tracks ()',color='grey')
    ax2.yaxis.set_tick_params(color='grey')
    plt.show()  

#%%
def main(locs,info,path,**params):
    '''
    Link localizations using trackpy.link_df() (`trackpy`_) on localizations (`picasso.localize`_) with given search_range and 
    memory to get trajectories sorted by group and frame. All tracks shorter or equal to 10 frames are removed. Trajectories 
    will be saved as ``'_picked%i%i.hdf5'%(search_range,memory)`` with corresponding info as .yaml.
    
    Args:
        locs(pandas.DataFrame):    Localization list, i.e. _locs.hdf5 as in `picasso.localize`_
        info(list):                Info _locs.yaml to _locs.hdf5 localizations as list of dictionaries.
        path(str):                 Path to _locs.hdf5 file.
        
    Keyword Args:
        search_range(int):             Localizations within search_range (spatial) will be connected to tracks (see trackpy.link_df)
        memory(int):                   Localizations within memory (temporal) will be connected to tracks (see trackpy.link_df)
    
    Returns:
        list:
            
        - [0](dict):             Dict of keyword arguments passed to function.
        - [1](pandas.DataFrame): Trajectories by application of trackpy.link_df(). See above.
    '''
    
    ##################################### Params and file handling
    
    ### Path of file that is processed and number of frames
    path=os.path.splitext(path)[0]  
    
    ### Define standard 
    standard_params={'search_range':5,
                     'memory':3,
                     }
    ### Remove keys in params that are not needed
    for key, value in standard_params.items():
        try:
            params[key]
            if params[key]==None: params[key]=standard_params[key]
        except:
            params[key]=standard_params[key]
            
    ### Remove keys in params that are not needed
    delete_key=[]
    for key, value in params.items():
        if key not in standard_params.keys():
            delete_key.extend([key])
    for key in delete_key:
        del params[key] 
        
    ### Processing marks
    params['generatedby']='spt.linklocs.get_link()'
    
    ### Prepare file extension for saving
    sr='%i%i'%(int(params['search_range']/10),
               np.mod(params['search_range'],10),
               )
    mr='%i%i'%(int(params['memory']/10),
               np.mod(params['memory'],10),
               )
    
    ##################################### Link
    link=get_link(locs,
                  search_range=params['search_range'],
                  memory=params['memory'],
                  )
    
    
    ##################################### Save
    #### Save complete link as _picked    
    info_picked=info.copy()+[params] 
    io.save_locs(path+'_picked%s%s.hdf5'%(sr,mr),
                  link.to_records(index=False),
                  info_picked,
                  )
    
    ### Save reduced version (only first 500 groups!) of link for viewing in render
    try:
        max_group=link.group.unique()[500]
    except:
        max_group=link.group.unique()[-1]
    link_view=link[link.group<=max_group]
    
    io.save_locs(path+'_picked%s%s'%(sr,mr)+'g500.hdf5', 
                  link_view.to_records(index=False),
                  info_picked,
                  )
    
    return [params,link]